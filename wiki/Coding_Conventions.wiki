#summary Coding conventions used in this project
#labels Phase-Design,Phase-QA,Phase-Implementation

= Casing =
_Revise these?_
 * Class names should be in `CamelCase`.
 * Method names should be `concatenated_by_underscores`.
 * Macros names must be in `ALL_CAPS`.

= Namimg =
 * Method names should retain the original C method names if possible, e.g.
   * `igraph_vector_null` → `igraph::Vector.null`
   * `igraph_degree` → `igraph::Graph.degree`
   * `igraph_vs_as_vector` → `igraph::VertexSelector.as_vector` 
 * If no ambiguity is introduced between the name and the actual function, then function may be overloaded, e.g.
   * degree() return degree of all nodes, while degree(6) return degree of node 6.
 * Use the named constructor idiom unless default constructor really express its default meaning, e.g.
   *  Use `igraph::Vector::seq(Integer, Integer)` instead of `igraph::Vector::Vector(Integer, Integer)`. An uninformed seeing the statement `Vector(5., 12.)` may think you are creating a vector with 2 elements.

= Types =
 * Use named enums instead of magic booleans to give a clear meaning to the readers.
 * Use typedef to specify the usage of a general type. For example, Vertex and Edge are both typedefs of the generic type Integer.
 * Return a wrapper type instead of STL type for containers. (e.g. Vector instead of `std::vector<T>`). Users should be instructed to switch between STL and igraph containers by iterators:
   * `std::vector<Integer> stl_vector = std::vector<Integer> (igraph_vector.begin(), igraph_vector.end());`
   * `Vector igraph_vector = Vector (stl_vector.begin(), stl_vector.end());`
 * Always keep in mind that the igraph Integer is typedef-ed to be a double, not an int.

= Language features =
 * Avoid use of GCC C extensions, TR1 libraries or C++0x features, as these are not available in every compilers. If you really need these, you must provide an alternative that gives the same result when these feature are absent. You can test for each of these with:
   * GCC: `#if __GNUC__`
   * C++0x: `#if __GXX_EXPERIMENTAL_CXX0X__ || __cplusplus > 199711L`
 * Avoid the use of non-standard library, such as boost libraries. If the functionality of some library is required, all source code should be added them in this project.
 * Some of these features, however, have been dealt with, so you may freely use them. They are:
   * `__attribute__`
   * `std::move`
 * Avoid using boost features (e.g. `foreach`). Some people may not bother to download and configure boost.
 * All internal macro should be prefixed by `XXINTRNL_` so normal people won't see it. They should be used only in the file that defines it. `#undef` them after using if possible.
   * *FIXME*: `XXINTRNL_WRAPPER_CONSTRUCTOR_***` currently breaks this rule.
 * Unless you need `realloc()`, always allocate memory with `new[]`/`delete[]` or `alloca()`.

= Enums =
 * To avoid polluting the shallower namespaces, if an enum is used by methods in only one class, then that enum must be placed in that class, i.e., instead of
  {{{
/** wrong **/
enum FileType {     // used nowhere else.
  Binary,
  ASCII
};
class File {
private:
  std::FILE* fptr;
public:
  File(const char* filename, FileType type); 
  // ...
};
}}}
 do it like this:
{{{
/** correct **/
class File {
private:
  std::FILE* fptr;
public:
  enum Type {     // used nowhere else.
    Binary,
    ASCII
  };
  File(const char* filename, Type type); 
  // ...
};
}}}
 Outside of the class you'd refer to the enum by File::Type and the values by File::Binary and File::ASCII.)